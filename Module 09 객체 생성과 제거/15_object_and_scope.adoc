= 객체와 범위

* 지역 값(Local value)의 수명은 선언된 범위에 연결됨
** 일반적으로 짧은 수명
** 결정론적인 생성과 소멸
* 동적 객체(Dynamic object)의 수명은 해당 범위에 연결되지 않음
** 보다 긴 수명
** 소멸 시기가 명확히 결정되지 않음

---

Stack에 할당되고 범위의 끝에서 소멸되는 int와 같은 값과는 달리 객체는 관리되는 Heap에 할당되고 범위의 끝에 해당되어도 소멸되지 않습니다.

== 값(Value)

지역 값의 수명은 선언된 범위에 연결됩니다. 여기서 범위는 메소드나 for, while등의 문을 말합니다. 지역 값은 Heap이 아닌 Stack에 할당되는 변수입니다. 유형이 기본 데이터 타입인 변수를 선언하면 선언한 범위 외부에서 사용할 수 없습니다. 

[source, java]
----
class Example {
    public static void main(String[] args) {
       for (int i = 0; i < 10; i++) {
            int j = 0;
        }
        j = 28;	// 컴파일시 오류
    }
}
----

지역 값은 아래와 같은 특성을 가집니다.

•	결정론적 생성과 소멸 +
지역 변수는 선언될 때 생성되고 선언된 범위의 실행이 종료되면 즉시 소멸됩니다. 값의 생성 시점과 소멸 시점은 명확히 결정됩니다. 
•	일반적으로 짧은 수명 +
메소드에서 값을 선언하면 그 값은 메소드 외부에서 존재할 수 없습니다. 메소드가 종료되며 값을 return하면 그 값의 복사본이 반환되고 실제 값은 소멸됩니다.

== 객체(Object)

객체의 수명은 객체가 생성된 범위와 관련이 없습니다. 객체는 `new` 연산자를 통해 할당된 Heap 메모리에서 초기화됩니다. 아래 코드에서 참조 타입 변수 `example` 은 `for` 문내에서 선언되었고, `for` 문의 밖에서는 `example` 변수에 액세스 할 수 없습니다. 그러나 `example` 은 Stack이 아닌 Heap에 객체로 초기화 되었으며 for 문이 종료되어도 소멸되지 않습니다. 참조 변수와 참조 변수가 참조하는 객체는 다릅니다.

[source, java]
----
class Example {
    public static void main(String[] args) {
       for (int i = 0; i < 10; i++) {
            Example example = new Example();
        }
        // example은 범위 밖에 있습니다.
        // example에는 도달할 수 없지만 존재합니다. (invisible)
    }
}
----

객체는 다음과 같은 특성이 있습니다:

•	결정되지 않은 소멸 시점 +
객체의 생성 시점은 명확하지만 값과 달리 생성된 범위의 실행이 끝나도 소멸되지 않습니다. 객체의 생성은 명확히 알 수 있지만 객체의 소멸은 그렇지 않습니다. Java에서는 객체가 소멸되는 시기를 정확히 제어할 수 없습니다.
•	더 긴 수명 +
객체는 객체를 만드는 메소드에 연결되어 있지 않기 때문에 객체는 단일 메소드 호출이 끝나도 계속 남아 있을 수 있습니다.

link:./14_object_lifecycle.adoc[이전: 객체 생명주기] +
link:./16_garbage_collection.adoc[다음: 가비지 컬렉션]