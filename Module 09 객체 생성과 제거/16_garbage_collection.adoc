= 가비지 컬렉션

* 객체는 명시적으로 소멸시킬 수 없음
** Java는 객체 생성 키워드와 반대의 동작을 하는 키워드(delete 등)가 없음
** 명시적 삭제 기능은 다른 언어에서 치명적 어류의 주요 원인이 됨
* 가비지 컬렉션이 프로그래머를 대신하여 객체를 제거
** 도달할 수 없는 객체를 찾아 자동으로 제거
** 사용되지 않는 Heap 메모리로 되돌리고(메모리를 반환하고) 마무리함
** 일반적으로 메모리가 부족할 때 가비지 컬렉션 작업을 수행

---

Java에서 객체를 생성하는 방법은 C++에서와 유사합니다. new 키워드를 사용하여 Heap에서 메모리를 할당하고 생성자를 호출하여 해당 메모리에 객체를 생성합니다. 그러나 객체를 소멸시키는 방법에 있어서는 다릅니다.

== 객체는 명시적으로 소멸시킬 수 없습니다

C++등과 같은 프로그래밍 언어에서 객체의 소멸 시기를 명시적으로 제어할 수 있습니다. C++에서는 delete 문을 사용하여 객체를 완결시키고 메모리를 원시 메모리로 되돌린 메모리 공간을 반환할 수 있습니다. Java에서는 이런 방법을 지원하지 않습니다. 많은 프로그램에서 객체의 명시적인 소멸이 많은 문제를 일으키기 때문에, 가비지 컬렉션을 사용하여 사용되지 않는 객체를 자동으로 소멸시키는 기능은 아주 유용합니다.

• 객체를 소멸 시키는 것을 종종 잊어버립니다. +
C++ 코드에서 발생할 수 있으며, 사용한 객체가 소멸되지 않고 메모리에 계속 존재함에 따라 프로그램이 메모리를 갈수록 많이 사용하게 되어 컴퓨터가 느려지는 문제가 발생합니다. 이를 메모리 누수(Memory Leak)라고 합니다. 이 경우 해결하는 유일한 방법은 프로그램을 다시 시작하는 것입니다.
• 같은 객체를 두 번 소멸시키려 할 수 있습니다. +
이미 소멸된 객체가 할당되어 있던 메모리에는 다른 객체가 생성되어 있을 수 있습니다. 이 문제는 심각한 오류를 발생시킵니다.
• 사용중인 객체를 소멸시킵니다. +
이것은 dangling pointer로 알려진 심각한 문제이며, 예기치 않은 결과를 낳습니다.

== 가비지 컬렉션

Java에서는 객체를 명시적으로 소멸시키는 코드를 작성하지 않아도 됩니다. Java는 가비지 컬렉션을 가지고 있어 사용되지 않는 객체를 소멸시켜 줍니다. 가비지 컬렉션은 자동으로 동작합니다.

• 객체를 소멸시킵니다. +
가비지 컬렉터는 객체를 소멸시키지만, 언제 소멸되는지는 정확히 지정하지 않습니다.
• 객체는 한 번만 소멸됩니다. +
C++에서 종종 발생하던 이 문제가 발생하지 않음을 의미합니다.
• 도달할 수 없는 객체만 소멸됩니다. +
가비지 컬렉션은 다른 객체가 참조하고 있는 경우 객체를 소멸시키지 않습니다. 따라서 dangling pointer로 알려진 버그가 발생하지 않음을 보장합니다. 가비지 컬렉션은 모든 객체를 조사하여 도달 가능성이 없는 객체를 찾습니다. 이 작업은 메모리가 부족할 때 시작됩니다.

link:./15_object_and_scope.adoc[이전: 객체와 범위] +
link:./17_review.adoc[다음: 검토]