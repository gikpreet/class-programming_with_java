////
= Singleton과 Prototpye 리포지토리

GoF 디자인 패턴 중, 생성 패턴에 속하는 ProtoType 패턴은 코드를 클래스들에 의존시키지 않고 기존 객체들을 복사할 수 있도록 하는 패턴입니다.

객체가 있고, 그 객체의 정확한 복사본을 만들고 싶을 경우, 일반적인 방식에서는 같은 클래스의 새 객채를 생성한 다음 원본 객체의 모든 필드를 새 객체로 복사해야 합니다. 하지만 이런 경우, 몇 가지 위험성과 불편한 점이 있습니다.

1. 원본 객체의 필드 중 일부는 private으로 선언되어 있어, 외부에서 볼 수 없다.
2. 해당 원본 객체의 클래스 소스코드를 알아야 할 필요가 있다.

프로토타입 패턴은 실제로 복제되는 객체들에 복제 프로세스를 위임합니다. 복제를 지원하는 객체를 프로토타입이라고 하며, 이 객체에는 자신의 복제본을 내부에서 만들어 반환하는 clone 메소드가 반드시 존재해야 합니다. 수십 개의 필드와 수백 개의 설정들이 존재하는 경우, 유용한 방법이 될 수 있습니다.

image:../images/image16.png[]

자주 사용하는 프로토타입들에 쉽게 접근하는 방법을 제공하려면, Prototype Registry를 사용할 수 있습니다. 이 레지스트리는 복사될 준비가 된 미리 만들어진 객체의 집합을 저장합니다.

image:../images/image17.png[]

== 문제

ProtoType 레지스트리를 만들고, 객체를 PrototypeRegistry에 등록한 다음 클래스의 이름으로 해당 클래스 인스턴스 객체의 복사본을 반환받을 수 있도록 구현하세요. 조건은 아래와 같습니다:

1. ProtoTypeRegistry 객체는 Singleton 이어야 합니다.
2. CreationType 이라는 이름의 Annotation을 만들고, type 속성에 ProtoType 값이 저장된 클래스의 객체를 등록하고, 등록된 객체를 반환 받을 경우 그 객체는 해당 클래스 인스턴스의 복제본이어야 합니다.
3. CreationType 이라는 이름의 Annotation을 만들고, type 속성에 Singleton 값이 저장된 클래스의 객체를 등록하고, 등록된 객체를 반환 받을 경우 그 객체는 전체 응용 프로그램에서 유일한 객체(Singleton)이어야 합니다.

== 제출 방법

* main 메소드가 포함된 클래스를 public으로 선언하고 팀이름_ProtoType 로 작성한다.
* 프로그램 동작에 필요한 모든 소스파일을 팀이름_ProtoType.zip 으로 압축한다.
* 팀이름_ProtoType.zip 파일을 제출한다.
* 전체 팀원의 이름을 반드시 기록한다.
 ////