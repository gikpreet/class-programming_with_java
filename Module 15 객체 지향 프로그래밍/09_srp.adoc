= SRP, Single Responsibility Principle

* 단일 책임 원칙
* 모든 클래스는 단 하나의 책임을 수행하는데 집중되어야 하며, 그 책임을 완전히 캡슐화 해야 한다
** 책임: “변경하려는 이유”
** 클래스나 모듈은 변경하려는 단 하나의 이유를 가져야 한다
** 해당 모듈이 여러 액터들에 대해 책임을 지지 않는다
* 변경이 필요할 때 수정할 대상이 명확해짐
* 응집도(Cohension)를 높이고 결합도(Coupling)를 낮춤
* 다른 원칙들을 적용하는 기초가 됨

---

THERE SHOULD NEVER BE MORE THAN ONE REASON FOR A CLASS CHANGE

**Single Responsibility Principle**, SRP라고 불리는 단일 책임 원칙은 모든 클래스는 하나의 책임만을 가지며, 클래스는 그 책임을 캡슐화해야 한다는 원칙입니다. 여기서 책임이란 변경하려는 이유(변화의 축)으로 정의되며, 어떤 클래스나 모듈은 변경하려는 단 하나의 이유만을 가져야 합니다. 이 원칙을 객체 지향 디자인에 적용하면 책임 영역이 확실해지기 때문에 한 책임의 변경에서 다른 책임의 변경으로의 연쇄 작용에서 자유로울 수 있습니다.

SRP 원칙은 클래스를 디자인할 때 책임을 적절히 분배하여 새 클래스를 생성하고 계층 구조를 만드는 것이 목적이므로, 단일 클래스의 코드가 간결 해지며 가독성이 향상되고 유지보수가 용이 해집니다.

SRP는 객체 지향 설계의 대 원칙인 OCP(Open Close Principle) 뿐만 아니라 다른 객체지향 설계 논리들을 적용하는 기초가 됩니다. 이 원칙은 다른 원칙들에 비해 개념이 단순하지만, 이 원리들을 적용해서 클래스를 설계하는 것은 쉽지 않습니다.

== Extract Class
Extract Class는 마틴 파울러의 책 <Refactoring: Improving the Design of Existing Code>footnote:[<Refactoring: Improving the Design of Existing Code>, Martin Powler, Addision-Wesley, 1999]에 소개된 클래스를 분리하는 방법입니다.

Extract Class는 마틴 파울러의 책에서 소개된 객체지향 리팩토링의 한 방법으로, 두 개의 클래스가 해야 할 일을 하나의 클래스가 하고 있는 경우, 새로운 클래스를 만들어서 예전 클래스에서 새로운 클래스로 옮기는 방법입니다.

객체지향 설계에서 클래스는 분명하게 Abstraction되어야 하고, 명확한 책임을 가져야 합니다. 실제로 클래스는 점점 커집니다. 동작이 추가될 때도 있고 데이터가 추가될 때도 있습니다. 책임(변화의 축)이 점점 커지고 늘어남에 따라 클래스는 지나치게 복잡해집니다. 이런 클래스는 많은 메소드와 데이터를 가지고 있고, 이해하기 힘들 정도로 큽니다. 이런 경우 클래스를 분리할 방법을 생각하고, 클래스를 분리해야 합니다.

Extract Class 방법은 Move Method, Move Field 두 가지 방법을 사용합니다.

== Move Method
메소드가 자신이 정의된 클래스보다 다른 클래스의 기능을 더 많이 사용하고 있다면, 이 메소드를 가장 많이 사용하고 있는 클래스에 비슷한 몸체를 가진 새로운 메소드를 만들고, 이전 메소드는 간단한 위임으로 바꾸거나 완전히 삭제하는 방법입니다. 절차는 아래와 같습니다.

1.	옮길 대상이 되는 메소드에 의해 사용되는 부분을 모두 조사한다.
2.	소스 클래스의 서브 클래스나 슈퍼 클래스에서 옮기려고 하는 메소드에 대한 다른 선언이 있는지 확인한다.
3.	타겟 클래스에 메소드를 정의한다.
4.	소스 메소드에서 타겟 메소드로 코드를 복사한다. 그리고 그 메소드가 타겟 클래스에서 동작하도록 적절히 수정한다.
5.	타켓 클래스를 컴파일 한다.
6.	소스 클래스에서 적절한 타켓 객체를 참조하는 방법을 결정한다.
7.	소스 메소드를 위임 메소드로 바꾼다.
8.	컴파일, 테스트를 한다.
9.	소스 메소드를 제거한다면 소스 메소드를 참조하고 있는 부분을 타겟 메소드를 참조하도록 수정한다.
10.	컴파일, 테스트를 한다.

== Move Field
필드가 자신이 정의된 클래스보다 다른 클래스에 의해 더 많이 사용되고 있다면, 타겟 클래스에 새로운 필드를 만들고 기존 필드를 사용하는 모든 부분을 변경하는 방법입니다. 절차는 아래와 같습니다.

1.	필드가 public으로 선언되어 있으면 캡슐화 한다.
2.	컴파일, 테스트를 한다.
3.	타겟 클래스에 필드와 그 필드에 대한 get/set 메소드를 만든다.
4.	타겟 클래스를 컴파일 한다.
5.	소스 클래스에서 타겟 클래스를 참조하는 방법을 결정한다.
6.	소스 클래스에 있는 필드를 제거한다.
7.	소스 필드를 참조하고 있는 모든 부분을 타겟 클래스에 있는 적당한 메소드를 참조하도록 바꾼다.
8.	컴파일, 테스트를 한다.

link:./08_introduction_solid.adoc[이전: 객체지향 디자인 원칙] +
link:./10_lab15-1.adoc[다음: Lab 15-1 BankAccount클래스 리팩토링]