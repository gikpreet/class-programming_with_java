= OCP, Open Closed Principle

* 개방 폐쇄 원칙
* 소프트웨어는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
** 요구사항의 변경이나 추가사항이 발생하더라도 기존 구성요소에는 수정이 일어나지 않아야 함
** 쉽게 확장이 가능하여 재사용 가능하도록 구성되어야 함
** 계층 구조 설계 시 변경될 수 있는 부분과 변하지 않을 부분을 명확히 구분
** 변하는 것들은 숨기고 변하지 않는 것들에 의존
* 객체지향 프로그래밍의 핵심 원칙
* 관리 가능하고 재사용 가능한 코드를 만드는 기반
* 추상화를 이용해 가능한 동작의 묶음을 표현하고 인터페이스로 구현한 후 서브 티이핑
* 추상화는 개방 폐쇄 원칙의 핵심요소

---

YOU SHOULD BE ABLE TO EXTEND A CLASSES BEHAVIOR, WITHOUT MODIFYING IT

**Open Close Principle**, OCP라고 불리는 개방 폐쇄 원칙은 소프트웨어 개체(클래스, 모듈, 함수)는 확장에 대해는 열려 있어야 하고, 변경에 대해서는 닫혀 있어야 한다는 원칙입니다. 1998년 버틀란트 메이어(Bertrand Meyer)가 <Object-Oriented Software Construction><sup>[3]</sup> 이라는 책에서 정의한 내용으로 변경을 위한 비용은 가능한 줄이고 확장을 위한 비용은 가능한 극대화해야 한다는 의미입니다.

소프트웨어에 포함된 클래스 구조를 리팩토링하여 나중에 변경이 있을 때 수정이 아닌 확장으로, 즉 기능을 추가하거나 변경해야 할 때 이미 제대로 동작하고 있던 코드를 변경하지 않고 새로운 클래스나 모듈, 함수를 추가함으로써 기능이 추가나 변경이 가능하도록 프로그램을 작성해야 합니다.

버틀란트 메이어는 이 원칙을 적용하기 위해 상속을 사용해야 한다고 제안했습니다. 그러나 상속은 서브 클래스가 구현에 의존하는 경우 슈퍼 클래스의 세부 정보와 긴밀하게 결합합니다. 따라서, SOLID 원칙을 정리한 로버트 마틴은 개방 폐쇄의 원칙을 인터페이스를 사용하여 정의된 행위(Behavior)를 정의하고, 정의된 코드를 쉽게 대체할 수 있는 다양한 구현을 허용하는 원칙으로 재 정의했습니다.

OCP는 관리 가능하고 재사용 가능한 코드를 만드는 기반이며, 이를 가능하게 만드는 주요 요소는 Abstraction와 Polymorphism입니다. OCP는 객체지향의 장점을 극대화하는 아주 중요한 원리입니다.

== 확장에 대해 열려 있다.
클래스나 모듈을 확장할 수 있다는 것을 의미합니다. 응용 프로그램의 요구사항이 변경될 때, 이 변경에 맞게 새로운 동작을 추가하여 클래스나 모듈을 확장할 수 있어야 합니다.

== 수정에 대해 닫혀 있다.
클래스나 모듈의 코드를 수정하지 않아도 모듈의 기능을 확장하거나 변경할 수 있어야 합니다. 확장을 통해 변경이 일어나도 기존의 실행가능한 바이너리(dll이나 jar)를 재 컴파일하거나 재 작성하지 않아도 되어야 합니다.

소프트웨어 디자인에 OCP 원칙을 적용하기 위해서는 SRP 원칙에 입각하여 변경될 것과 변경되지 않을 것을 엄격하게 구분해야 합니다. 변경될 수 있는 것으로 구분된 요소와 그렇지 않은 요소가 만나는 부분에 인터페이스를 정의하고, 모든 코드는 구현 클래스가 아닌 인터페이스에 의존하도록 코드가 작성되어야 합니다.

이때, 추상화 원칙들을 잘 적용해야 합니다. UML의 창시자중 한명인 Grady Booch는 추상화란 다른 모든 종류의 객체로부터 식별될 수 있는 객체의 본질적인 특징이라고 정의했습니다. 이 본질적인 특징을 추상화를 통해 명확히 정의할 수 있어야 합니다.

본질적인 특징을 추상화를 통해 정의할 수 있고, 정의된 본질적인 특징은 타입으로 정리될 수 있습니다. C++, Java, C#과 같은 객체지향 프로그래밍 언어에서 타입을 정의하는 유일한 방법은 인터페이스이고, 인터페이스는 이런 변하지 않을 본질적인 특징에 대한 약속입니다.

link:./11_example.doc[이전: 연습문제] +
link:./13_lab15-2.adoc[다음: Bank 예제 프로그램에 계정 타입 추가]