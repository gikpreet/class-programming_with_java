= LSP, Liskov Substitution Principle

* 리스코프 치환 원칙
* 타입 S가 타입 T의 서브타입이라면 프로그램의 속성 변경없이 T 타입의 객체를 S 타입으로 치환할 수 있어야 한다.
** 서브 타입은 수퍼 타입을 대체할 수 있어야 한다
** 해당 객체를 사용하는 클라이언트는 상위 타입이 하위 타입으로 변경되어도 차이점을 알지 못한 채 수퍼 타입의 인터페이스를 통해 서브 클래스를 사용할 수 있어야 함
* 버트란트 메이어의 계약에 의한 설계(Design by Contract)와 유사성을 지님
* 참조되는 기반 클래스의 함수는 파생 클래스의 상세를 알지 않고 사용 가능해야 함
* 추상 클래스의 순수 가상 함수로부터 클래스를 파생시킴으로서 추상화된 다형적 인터페이스를 만들어 낼 수 있음
* OCP를 위반하지 않도록 하는 기반 원칙

---

FUNCTIONS THAT USE POINTERS OR REFERENCES TO BASE CLASSES MUST BE ABLE TO USE OBJECTS OF DERIVED OBJECTS OF DERIVED CLASSES WITHOUT KNOWING IT.

**Liskov Substitution Principle**, LSP라고 불리는 리스코프 치환 원칙은 서브 타입은 언제나 슈퍼 타입으로 교체할 수 있어야 한다는 원칙입니다. 타입 T에서 파생된 타입 S가 타입 T로 치환되면 필요한 프로그램의 속성의 변경없이 동일하게 동작해야 한다는 뜻입니다. 이는 강한 행동적 하위형화 (Strong behavioral subtyping)라고 부르는 서브 타이핑 관계의 특정한 사례입니다. 이 정의는 타입의 의미론적 상호 처리를 보장하므로, 단순한 문법적 관계일 뿐만 아니라 의미론 적 관계이기도 합니다.

== 계약에 의한 설계(Design by Contract)
계약에 의한 설계는 버틀란트 메이어가 만든 개념으로 프로그램의 책임을 문서화하는데 초점을 맞춥니다. 각각의 모듈이 가져야 하는 기능만큼만 동작하도록 만들며, 이런 개념을 문서화하고 검증하는 것이 Design by Contract의 핵심입니다.

모듈을 호출하여 동작 시킬 때 어떤 인자를 파라미터로 전달해야 하는지, 그리고 어떤 결과를 Return 받아야 하는지 등을 결정해야 하는데, 모듈을 호출하기 위해 True이어야 하는 것을 선행 조건(Pre-condition), 모듈이 수행할 것이라고 보장하는 것을 후행 조건(Pre-condition)이라고 합니다. 불변식(Invariant)은 호출자의 입장에서 이 조건이 언제나 True라고 보장하는 것을 말합니다.

계약은 피호출자(모듈, 클래스 등)와 호출자사이에서 지켜야 하는 것들을 말합니다. 계약 조건은 아래와 같습니다.

> 만약 호출자가 모듈의 모든 선행조건을 충족한다면, 해당 모듈은 모든 후행조건과 불변식이 true일 것을 보증해야 한다.

간단한 BankAccount 클래스의 경우를 생각해 봅시다. 모든 계좌가 가지고 있어야 하는 행위(Behavior)를 정의한 IBankAccount라는 인터페이스를 아래와 같이 정의 했습니다.

[source, java]
----
interface IBankAccount {
    BigDecimal getBalance();
    BigDecimal deposit(BIgDecimal amount);
    Boolean withDraw(BigDecimal amount);
}
----

이렇게 정의된 인터페이스는 실제로 BankAccount를 구현하는 클래스를 작성하는 개발자의 입장에서는 명확하지 않습니다. 예를 들면 withDraw 메소드를 구현할 때 잔고보도 많은 돈을 인출하려 하면 어떻게 될것인가, 잔고가 마이너스가 되면 대출로 처리할 것인가 등에 대해 명확하지 않습니다. 이런 문제는 요구사항을 분석하는 단계에서 논의되었을 것입니다. 계약에 의한 설계는 이런 인터페이스를 구현하는 클래스에 대한 선행 단계, 후행 단계와 불변식의 내용을 명확히 기술하여 오류 없는 프로그램을 작성하는데 의의를 두고 있습니다.

이 문제에 대한 전통적인 해결 방법은 주석을 사용하는 것입니다.

[source, java]
----
/**
* 이 클래스는 고객의 은행 계좌를 표현합니다.
* 잔고는 0이하로 표시될 수 없습니다.
* 잔고보다 많은 출금 시도는 반드시 거절됩니다.
*/
interface BankAccount {
    /*
    * Post-condition: 계좌의 잔고를 반환합니다. 잔고는 반드시 0보다 큽니다.
    */
    BigDecimal getBalance();

    /* Pre-condition: 입금되는 금액은 0보다 작을 수 없습니다.
	* post-condition: 잔고에 입금된 금액을 더하고 더한 값을 반환합니다. 반환 값은 양수입니다.
	*/
    BigDecimal deposit(BigDecimal amount);

    /* Pre-condition: 출금 요청 금액은 0보다 작을 수 없습니다
    * Post-condition: 잔고가 출금 요청금액보다 클 경우, 잔고에서 요청금액을 빼고 true를 return합니다. 잔고가 출금 요청 금액보다 작을 경우, 계산하지 않고 false를 반환합니다.
    */
    boolean withDraw(BigDecimal amount);
}
----

위 코드는 명세서에 나와있는 제약 조건을 주석 형태로 코드에 삽입했습니다. 인터페이스를 사용하는 클라이언트는 관련된 내용을 쉽게 알 수 있습니다. BankAccount 타입을 사용하는 클라이언트는 인터페이스 메소드들의 주석을 읽고 클라이언트가 지켜야 하는 제약을 알 수 있습니다. deposit() 메소드를 호출할 때 amount 인자에 음수를 넘기면 안된다는 것을 알 수 있으며, getBalance() 메소드의 return 값은 항상 양수라는 것을 알 수 있습니다.

== 리스코프 치환 원칙
행동적 하위형(Behavioral Subtype)이라는 개념은 객체에 대한 대체 가능성(Notion of substitutability for object)을 정의하는 것입니다. 즉,

> 타입 S가 타입 T의 서브 타입이라면, 프로그램에서 타입 T의 객체는 프로그램을 수정하지 않고 자료형 S로 대체될 수 있다.

라는 것을 의미합니다. 이 원칙은 타입 이론에서 일반적으로 사용되는 일반적인 서브 타입 지정보다 더 강력한 개념입니다. 행동적 서브 타입 지정(Behavioral Subtyping)은 일반적으로 결정할 수 없고 이 원칙이 지켜지는 지를 검증하는 것은 불가능하지만, 클래스 계층 구조 설계에서 유용하게 사용될 수 있습니다.

리스코프 치환 원칙은 시그너처에 대한 몇 가지 요구사항들을 적용하도록 강제합니다.

* 서브 타입에서 메소드 파라미터 타입은 반공변성(Contravariance)
* 서브 타입에서 메소드 return 타입의 공변성(Covariance)
* 서브 타입에서 메소드는 상위 클래스의 메소드에서 throw한 하위형을 제외하고 새로운 예외를 던질 수 없음

여기에 더해서 서브 타입이 만족해야 하는 행동 조건 몇 가지가 더 있습니다. 이것인 계약이 상속에 대해 어떻게 상호작용 하는지에 대한 정의를 위해 계약에 의한 설계를 도입하여 정의합니다.

* 서브 타입에서 Pre-condition은 강화될 수 없다.
* 서브 타입에서 Post-condition은 약화될 수 없다.
* 서브 타입에서 수퍼 타입의 불변형은 반드시 유지되어야 한다.
* 이력 제약 조건(History constraint - History rule)

객체는 그 자신의 메소드를 통해서만 수정(캡슐화) 될 수 있는 것으로 간주된다. 서브 타입은 수퍼 타입에 없는 메소드를 추가할 수 있기 때문에, 추가된 메소드를 통해 수퍼 타입에서 허용하지 않는 서브 타입 상태의 변경을 일으킬 수 있다. LSP에 도입된 이 제약조건은 이를 방지한다. 이 제약조건의 위반을 정의하기 위해 변경 가능 지점(mutable point)를 변경 불가 지점(immutable point)의 서브 타입으로 만들 수 있다. 변경 불가 지점의 이력은 생성한 이후 상태가 항상 동일해야 하기 때문에, 앞에서 가능한 정의는 이력 제약 조건의 위반이며 따라서 변경 가능 위치를 이력에 포함할 수 없다. 반면 서브 타입에 추가된 필드는 수퍼 타입의 메소드로 감시할 대상이 아니기 때문에 안정적으로 수정할 수 있다.

[cols="1a"]
|===
| **참조** 
공변성(Covariance)은 한 변수가 변하면 다른 변수도 변하는 성질을 말하며, 반공변성은 그 반대의 성질을 말합니다.

“우리가 얻은 중력장 방정식은 일반 좌표 변환에 대한 공변성을 갖고 있지 않습니다. 단지 선형 변환에 대한 공변성만 확인되었을 뿐입니다 (2015년 1월 동아 사이언스)”
“공변성의 원칙은 변수들 간의 인과적 관계를 나타내는 일차적인 조건이 된다(김경우, 사회복지 조사 방법론, 엠제이 미디어, 2008)”

서브 타이핑은 프로그래밍 언어에서 까다로운 주제입니다. 그리고 공변성과 반공변성(Covariance와 Contravariance)는 객체지향에서 중요한 개념 중의 하나입니다.

A <: B A는 B의 서브 타입
A -> B 함수 타입으로, 함수의 파라미터 타입은 A이며 return 타입은 B

라고 정의하고, 아래와 같은 세 타입이 있다고 가정할 경우

Pomeranian <: Dog <: Animal

서브타입은 일반적으로 transitive한 관계를 가지므로 Pomeranian도 Animal의 서브 타입이 됩니다. 서브 타입 관계에서 함수 타입 관계를 연관 지어 다음을 생각해봅시다.

다음 중 Dog -> Dog의 서브 타입이 될 수 있는 것은?

1.	Pomeranian -> Pomeranian
2.	Pomeranian -> Animal
3.	Animal -> Animal
4.	Animal -> Dog
5.	Animal -> Pomeranian

Dog -> Dog 함수를 인자로 받는 함수 f가 있습니다. 반환 타입에 대해서는 크게 생각하지 않습니다.

f: (Dog -> Dog) -> String

f를 다른 함수인 g와 함께 호출해보면서 Dog -> Dog의 서브 타입 여부에 대해 생각해봅니다. g는 위의 각 함수입니다.

1.	g: Pomeranian -> Pomeranian 으로 가정하면 f(g)는 타입 안전(type safe)한가?
아닙니다. 함수 f는 인자 g를 사용하면서 Dog의 다른 서브타입, 예를 들면 Maltese를 이용해서 호출할 수도 있기 때문입니다.
2.	g: Pomeranian -> Animal 으로 가정하면 f(g)는 타입 안전한가?
아닙니다. 함수 f는 인자 g를 사용하면 Dog의 다른 서브타입, 예를 들면 Poodle을 이용해서 호출할 수도 있기 때문입니다.
3.	g: Animal ->Animal 으로 가정하면 f(g)는 타입 안전한가?
아닙니다. f에서 인자 g를 호출하면서 개가 어떻게 짖는지 그 반환 값을 얻으려고 할 수 있습니다. 하지만 모든 Animal이 짖는 것은 아닙니다.
4.	g: Animal -> Dog 으로 가정하면 f(g)는 타입 안전한가?
예, 이 경우는 안전합니다. f 함수는 인자인 g를 호출할 때 어떤 종류의 Dog 이든 사용할 수 있습니다. 모든 Dog은 Animal이기 때문입니다.
5.	g: Animal -> Pomeranian 으로 가정하면 f(g)는 타입 안전한가?
예, 이 경우는 안전합니다. f 함수는 인자인 g를 호출할 때 Pomeranian을 사용할 수 있습니다. 모든 Pomeranian은 Dog이기 때문입니다.

따라서, 다음 경우에 안전합니다.

(Animal -> Dog) <: (Dog -> Dog)
(Animal -> Pomernian) <: (Dog -> Dog)

반환 타입은 생각보다 간단합니다. Pomernian은 Dog의 서브 타입입니다. 인자 타입은 반대입니다. Animal은 Dog의 수퍼 타입입니다.

이 동작방식을 용어를 사용해서 설명하면 다음과 같습니다.

* 함수 타입에서 반환 타입은 공변적(covariance)이고, 파라미터 타입은 반공변적(contravariance)입니다.
* 반환 타입의 공변성은 A <: B가 (T -> A) <: (T - > B)로 적용됩니다.
* 인자 타입의 반공변성은 A <: B가 (B -> T) <: (A -> T)로 적용됩니다.
|===

link:./14_example2.adoc[이전: 연습문제] +
link:./16_lab15-3.adoc[다음: Lab 15-3 Circle-ellipse Problem]
