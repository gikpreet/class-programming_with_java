= 잠자기와 깨우기

* 피터슨 알고리즘과 TSL은 바쁜 대기를 요구
** CPU를 낭비할 뿐만 아니라 예측하지 못한 결과를 가져옴
** 우선 순위 도치 문제(Priority Inversion Problem)를 해결하기 어려움
* 프로세스가 임계구역에 들어갈 수 없을 때 CPU 시간을 낭비하는 대신 블록시키는 통신 수행
* 잠자기와 깨우기(Sleep and Wakeup) 방법

---

피터슨 알고리즘과 TSL은 바르게 동작하지만 모두 바쁜 대기를 요구하는 단점을 가지고 있습니다. 본질적으로 이 방법들이 하는 일은 다음과 같습니다.

1.	한 프로세스가 임계구역에 들어가려고 할 때 가능 여부를 검사합니다.
2.	만약 프로세스가 임계구역에 들어갈 수 없다면 루프 상타에서 들어갈 수 있을 때까지 기다리는 바쁜 대기를 한다.

이 접근법은 CPU를 낭비할 뿐만 아니라 예측하지 못하는 결과를 가져올 수도 있습니다. 어느 한 컴퓨터가 높은 우선순위를 가진 H와 낮은 우선순위를 가진 L인 두 프로세스를 가지고 있다고 할 때, 이 시스템 스케줄링 규칙에 의해 H는 준비상태에 있게 되면 언제나 실행됩니다. 그러나 어떤 순간, L이 임계 구역에 있을 때 H가 준비상태가 될 수 있습니다. 그러면 H는 바쁜 대기 상태에 놓이게 되며, H가 실행되는 동안 L은 스케줄링 되지 않으므로 L은 임계 구역을 떠날 기회를 가질 수 없게 됩니다. 이런 경우 H는 무한정 루프를 돌게 됩니다. 이선 상태를 우선 순위 도치 문제(Priority Inversion Problem)라 합니다.

프로세스가 임계 구역에 들어갈 수 없을 때 CPU 시간을 낭비하는 대신에 블록시키는 프로세스간 통신을 생각할 수 있습니다. 대표적인 경우가 잠자기와 깨우기(Sleep and Wakeup)입니다. sleep은 시스템 호출로 호출자를 블록 시킵니다. 즉, 다른 프로세스가 깨울 때까지 보류시킵니다. wakeup 호출은 깨워야 할 프로세스를 하나의 파라미터로 갖습니다. 두 시스템 호출 모두 두 호출을 대응시키는데 사용되는 하나의 메모리 주소를 파라미터로 갖습니다.

link:./16_생산자_소비자_문제.adoc[다음: 생산자 소비자 문제]