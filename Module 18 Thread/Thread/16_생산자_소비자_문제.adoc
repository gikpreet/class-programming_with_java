= 생산자-소비자 문제

* 여러 개의 프로세스를 어떻게 동기화 할 것인가에 대한 고전적인 문제
** 생산자가 데이터를 생성하면 소비자는 그것을 소비하는 형태에서 발생하는 문제
** 생산하는 속도와 소비하는 속도에 차이가 존재
** 일반적으로 생산 속도가 빨라, 생산된 데이터는 바로 소비되지 못함
** 생산된 데이터를 보관하는 버퍼 공간을 주고 소비자는 버퍼에서 데이터를 빼내어 사용
** 생산자는 버퍼가 가득차면 넣을 수가 없고, 소비자는 버퍼가 비면 뺄 수가 없음
* 한정 버퍼(Bounded Buffer Problem)이라고도 부름
* 세마포어(Semaphore) +
두 원자적 함수로 조작되는 정수 변수로, 공유 자원에 대한 접근을 제한하는 방법으로 사용
* 뮤텍스(Mutual Exclusion) +
한 프로세스의 내부에서 여러 Thread의 임계구역 제어를 위해 사용되는 객체

---

생산자-소비자 문제는 여러 개의 프로세스를 어떻게 동기화 할 것인가에 대한 고전적인 문제로, 생산자가 데이터를 생성하면 소비자는 그것을 소비하는 형태에서 발생하는 문제입니다. 웹 서버가 데이터를 생산하여 웹에 관련되어 보여주는 작업들을 수행하고 웹 클라이언트는 웹 주소로 접속해 화면을 보게 되는 형태의 작업이 이 경우에 속합니다.

두 프로세스는 고정된 크기의 공유 버퍼를 갖고 있습니다. 하나는 이 버퍼에 정보를 넣는 생산자이고 다른 하나는 버퍼에서 정보를 꺼내어 사용하는 소비자입니다. 

생산자가 새 항목을 버퍼에 넣으려고 할 때 버퍼가 차 있으면 문제가 발생합니다. 해법은 생산자를 재우고 소비자가 한 항목 이상을 가져간 후에 생산자를 깨우는 방법입니다. 마찬가지로 소비자가 항목을 가져가려고 할 때 버퍼가 비어있다면, 소비자는 생산자가 항목을 넣어줄 때까지 자고 있어야 합니다. 

이 접근법은 간단해 보이지만 스풀러 디렉토리의 예에서 보듯이 경쟁 조건이 일어납니다. 버퍼에 있는 항목 수를 알기 위해서는 하나의 변수 count가 필요합니다. 버퍼 크기가 N이라면 생산자 코드는 이 변수 값이 N인지를 먼저 검사하여야 할 것이다. 그 값이 N이면 생산자는 자야 할 것이고, 그렇지 않으면 생산자는 항목을 버퍼에 넣고 count 값을 증가시킬 것입니다. 

소비자 코드도 유사합니다. 먼저 count 값이 0이면 자게 되고, 0이 아니면 하나를 소비하고 count 값을 감소시켜야 합니다. 각 프로세스는 상대 프로세스의 상태를 알아보고 깨워야 한다면 깨워주어야 합니다. 

이 경우, count에 대한 접근은 제한이 없으므로 경쟁이 일어납니다. 버퍼는 비어있고 소비자는 0인지를 알기 위해 count 값을 막 읽은 상태일 때, 스케줄러가 일시적으로 소비자를 멈추고 생산자를 수행시키기로 정했습니다. 생산자는 한 항목을 만들어 버퍼에 넣고 count를 1로 증가시킵니다. 생산자는 지금까지 count 값이 0임을 알기 때문에 소비자는 자고 있다고 판단하고 소비자를 깨웁니다.

문제는 소비자는 논리적으로 자는 상태가 아니기 때문에 wakeup 시그널은 분실됩니다. 소비자가 다음을 실행할 때 미리 읽어두었던 count 값을 검사하고 0임을 알게 되어 자버리고 만다는 것입니다. 결국 생산자도 버퍼를 채우게 되고 잠들게 되면 두 프로세스는 영원이 자게 됩니다.

여기서 문제의 본질은 잠들지 않은 프로세스에게 wakeup 시그널이 보내지고 그 시그널이 분실되는 것입니다. 이 시그널이 분실되지 않으면 문제는 없습니다. 좋은 해결책은 이 상황에서 깨우기 대기 비트(wakeup waiting bit)를 추가하는 것입니다. wakeup 시그널이 깨어있는 프로세스에게 보낼 때 이 비트가 세팅됩니다. 이후 그 프로세스가 자려고 할 때 이 비트가 on 상태이면 다시 off 상태로 바꾸고 자지 않고 계속 깨어 있게 됩니다. 

== 세마포어(Semaphore)

다익스트라가 1965년에 제안한 wakeup 수를 카운트하기 위한 정수 변수입니다. 세마포어는 wakeup이 하나도 없는 0 값을 가질 수도 있고, 하나 이상이 보류되어 있는 양의 정수 값을 가질 수도 있습니다. 

세마포어는 sleep과 wakeup에 대응되는 두 개의 동작 down, up을 갖습니다. down 동작은 해당 세마포어 변수가 0보다 큰지를 검사합니다. 큰 값이면 1만큼 감소시키고 계속합니다. 0이면 프로세스는 바로 자게됩니다. 변수를 검사하고, 변경시키고, 잘 수 있게 하는 동작은 분리되지 않는 Atomic Operation으로 일어납니다. 이는 세마포어 동작이 시작되면 다른 어떤 프로세스도 이 동작이 완료되거나 블록되지 않는 한 액세스 할 수 없음을 의미합니다. 아 원자성(Atomicity)이 동기화 문제 해결이나 경쟁조건을 피하는데 절대적으로 필요합니다. 

up 동작은 지정한 세마포어의 값을 증가시킵니다. 만약 이전의 down 동작을 완료하지 못한 하나 이상의 프로세스가 그 세마포어에서 자고 있다면 시스템은 그들 중 하나를 선택하여 down 동작을 끝낼 수 있도록 합니다. 그러나 자고 있는 프로세스를 갖고 있는 세마포어 상에서 up 동작 이후에도 세마포어는 0값을 갖지만 이 세마포어에서 자고 있는 몇 개의 프로세스가 남아있을 수 있습니다. 세마포어 증가 동작과 한 프로세스를 깨우는 동작도 단위 동작으로 이루어집니다. down에서와 마찬가지로 up을 수행하는 중에도 어떤 프로세스도 블록되지 않습니다.

== 뮤텍스(Mutex - Mutual Exclusion)

세마포어의 카운트 기능이 필요없을 때 사용되는 세마포어의 간단한 버전으로, 어떤 공유 자원이나 세마포어의 간단한 버전이 자주 사용됩니다. 특히 사용자 공간에서 완전하게 구현될 수 있는 Thread 패키지에서 아주 유용하게 간단하고 쉽게 구현될 수 있습니다.

뮤텍스는 잠금과 풀림이라는 두 상태 중 하나를 갖는 변수로, 한 비트만으로 구현할 수 있으나, 실제로는 0을 풀림, 잠금으로는 다른 값을 이용합니다. 

link:./17_철학자들의_저녁식사.adoc[다음: 철학자들의 저녁식사]